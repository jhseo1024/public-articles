# C# Garbage Collection

Java, C#등 Managed Language 기반에서는 프로그래머의 개입없이 메모리를 자동 관리합니다. 처음에는 이부분이 프로그래밍의 난이도를 낮춰주지만, 게임 같은 고부하 서비스 환경에서는 적지 않은 문제를 야기하게 됩니다.

그러한 이유로 나중에 가서야 GC를 Supression(억제) 하려고 노력합니다. 아무래도 나중에 가서 이러한 현상들을 개선하려면 보통 힘든것이 아니므로, 미리 GC가 어떻게 동작하고 무엇이 문제가 되는지를 미리 짚어보면 서비스 상황에서 발생할수도 있는 문제들에 대해서 조금은 걱정을 덜수 있을것입니다.

혹자는 이렇게 얘기하기도 합니다. 편할려고 `GC`쓰는건데 그렇게 신경을 써야하나요. 네 맞습니다. 제생각에도 편할려고 쓰는데 이리 문제가 있다면, 근본적인 문제이지 않나 하는 생각도 했습니다.

사실상 이럴거면 `C/C++`를 사용해서 해당 문제를 완전히 피해가면 되지 않냐라고 반문할수 있습니다. 실제로 게임업계 특히 `MMORPG`급에서는 `C#`을 사용하는 것을 두려워하거나 금기시하는 곳이 많습니다. 또다른 이유로는 기존 코드베이스가 `C/C++`인 이유도 있겠죠. `MMORPG`를 제외한 적지않은 게임에서는 `C#`을 도입하곤 합니다. `C/C++` 대비 생산성이 월등하기 때문이죠. 컴파일 타임, 잘갖춰진 패키지들도 있고요. 제 개인적으로는 생각을 바로 결과로 옮기는데 큰 힘이 들지 않았던게 가장큰 장점이었던것 같습니다. `Visual Studio`, `Rider` 같은 `IDE`들이 너무 잘되어 있어서 어느정도 리듬만 타면 의식의 흐름이 코드로 표현되는 리듬을 타기도 수월했고요.

암튼, 여기서는 GC를 탑재한 Managed Language를 사용하냐 안하냐를 다룰려는 것은 아니고, C#의 GC관련해서만 다뤄보도록 하겠습니다.

## Garbage Collection

 먼저 Garbage Collection에 대해서 알아보겠습니다. 우리말로 `쓰레기 수집`으로 직영될 수 있습니다.
 
 여기서 말하는 `쓰레기`는 사용하고 반환되지 않은 메모리를 말합니다. 즉, 이 사용 후 반납되지 않은 메모리를 수집해서 가용 메모리로 반납하는 시스템인거죠.

 C/C++ 처럼 프로그래머가 직접 메모리를 할당하고, 해제해주는 환경과는 달리 편하지만 그로인한 댓가가 따릅니다. 사용되지 않는 메모리를 일일히 추적해야하고 더이상 참조를 가지지 않는 메모리를 반납하는 동작을 시스템이 임의의 타이밍에 이뤄진다는 것입니다.
 물론, 명시적으로 GC를 호출해서 반납해줄수 있지만, 부작용등이 있을 수 있으므로 그리 권장되는 방법은 아닙니다.
 결론적으로, 프로그래머의 의지와는 상관없이 `GC`가 발생할수 있다는 것이죠. 이로 인해서 게임같이 일정한 프레임을 유지해야하는 정밀한 실시간 환경에서는 프레임이 튀거나 반응이 들숙날숙할수 있습니다.

