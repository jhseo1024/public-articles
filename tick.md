게임 틱(Tick)에 대한 이해
---


게임 루프는 모든 게임에서 핵심이며, 게임루프가 없는 상태로는 실행되지 않습니다. 그러나 안타깝게도 개발에 입문하는 모든 게임 프로그래메에게는 이 주제에 대한 적절한 정보를 제공하는 문서는 찾아보기 힘든것 같습니다. 워낙 뻔한 내용이고 근간이 되는 부분이라 되려 관과되는건 아닌지 싶습니다. 차근 차근 상황별로 알아가보려고 하니, 부담은 내려두시고 따라 읽어 내려가 보시죠.

### 게임루프(Game Loop)

#### 게임 엔진의 기본흐름
![engineflow](https://i.imgur.com/Aem3Jth.png)

모든 게임은 사용자의 입력, 게임 상태 업데이트, AI 처리, 음악 및 음향 효과 재생 및 게임 표시순서로 구성됩니다. 이 시퀀스는 게임 루프를 통해 처리됩니다. 소개에서 말했듯이 이 게임 루프는 모든 게임의 핵심입니다.

실제 게임루프는 위의 그림 보다 더 복잡할 수 있습니다.
![updatecomponents](https://i.imgur.com/nW2Ap0N.png)

이 글에서는 위에서 언급한 작업에 대해 자세히 설명하지는 않고 게임 루프에만 집중할 것입니다. 그렇기 때문에 게임을 업데이트하고 표시하는 두가지 기능으로 작업을 단순화해서 설명하도록 하겠습니다.
가장 간단한 형태의 게임 루프 예제 코드는 다음과 같습니다.

```cpp
bool running = true;

while (running) {
    Update();
    Render();
}
```

이보다 더 간단한 루프의 형태는 없을겁니다. 하지만 이루프는 시간을 전혀 고려하지 않고 게임이 실행된다는데 문제가 있습니다. 하드웨어 속도가 느릴수록 게임 속도가 느려지는 문제가 있습니다. 시간을 고려해서 이러한 부분을 해결해야합니다.

#### FPS
`FPS` 즉, `Frames Per Second`의 약자입니다. 말뜻 그대로 1초에 몇프레임 처리할 수 있는지를 나타내는 수치입니다. 위에서 예시된 코드에서 보자면 `Update()`와 `Render()`가 `1초`에 `몇회 호출` 되었는지를 나타내는 수치입니다.

### 게임 속도(Game Speed)
게임 속도는 게임 상태가 초당 업데이트되는 횟수 즉, `Update()` 함수가 1초에 몇 회나 호출되는지를 나타내는 수치입니다.


## 일정한(Uniform) 게임 속도에 따른 FPS
타이밍 문제에 대한 쉬운 해결책은 초당 25프레임(한프레임당 40ms)으로 게임을 실행하는 것입니다.

![uniform_tick_timeline](https://i.imgur.com/Ckua51W.png)

```cpp
const uint32 FRAMES_PER_SECOND = 25;
const uint32 MSECS_PER_FRAME = 1000 / FRAMES_PER_SECOND;

uint32 nextFrameMs = GetMilliseconds();
uint32 sleepMs = 0;
bool running = true;

while (running) {
    Update();
    Render();

    nextFrameMs += MSECS_PER_FRAME;

    sleepMs = nextFrameMs - GetMilliseconds();
    if (sleepMs > 0) {
        // 의도한 프레임당 시간내에 처리 완료 (빠른 하드웨어 혹은 일시적 Idle)
        Sleep(sleepMs);
    } else {
        // 의도한 프레임당 시간내에 처리 못함 (느린 하드웨어 혹은 일시적 Load)
    }
}
```

이것은 하나의 큰 이점이 있는 방법이 될수 있습니다. `Update()`이 `초당 25번` 호출된다는 것을 알고 있기 때문에 코드를 작성하는 것이 아주 간단해집니다. 예를들어, 이런 종류의 게임 루프에서 재생 기능을 구현하는 것은 쉽습니다. 게임에서 임의의 값을 사용하지 않으면 사용자의 입력 변경 사항을 기록하고 나중에 다시 재생할 수 있습니다. 테스트 하드웨어에서 `FRAMES_PER_SECOND`를 적절한 값으로 설정할 수 있지만, 더 빠르거나 느린 하드웨어에서는 어떤 현상이 발생하는지 알아보도록 하겠습니다.

#### 느린 하드웨어
![nonuniform-tick-timeline](https://i.imgur.com/fpDuoj7.png)

하드웨어가 정의된 FPS를 처리할 수 있다면 아무런 문제가 없습니다. 그러나 하드웨어가 이를 처리할 수 없을때 문제가 시작될것입니다. 게임이 느려집니다. 최악의 경우 게임에는 게임이 실제로 느리게 진행되는 무거은 프레임들과 정상적으로 실행되는 프레임들이 있습니다. 타이밍이 가변적이어서 게임을 플레이할 수 없게 만들 수 있습니다.

#### 빠른 하드웨어
빠른 하드웨어에서는 게임을 실행하는데 전혀 지장이 없지만, 귀중한 클럭을 낭비하고 있습니다. `1000FPS`를 쉽게 수행할 수 있을때 `25FPS` 또는 `30FPS`에서 게임을 실행하면 하드웨어 자원을 제대로 활용하지 못하는것일 수 있습니다. 특히 빠르게 움직이는 물체의 경우 시각적으로 많은 호소력을 잃게 됩니다. 반면에 모바일 장치의 이점은 이점으로 볼 수 있습니다. 게임을 끊임없이 실행하지 않으면 배터리 시간을 절약할 수 있습니다. 게임 기획단계에서 목표 FPS를 정하는것이 좋습니다. 충분히 미세한 간격의 프레임을 표현할 필요도 없는 게임에서 과도한 FPS로 제한없이 사용하는것은 클럭낭비일 수 있습니다. 특히나 모바일에서는 배터리가 중요한 요소이므로 이부분을 고려한다면 배터리 타임을 길게 가져갈 수 있을것입니다.

#### 결론
`FPS`를 일정한 게임 속도에 의존하게 만드는 것은 빠르게 구현되고 게임 코드를 단순하게 유지하는 솔루션입니다. 하지만, 몇가지 문제가 있습니다. `높은 FPS`를 정의하면 느린 하드웨에서 문제가 발생하고, `낮은 FPS`를 정의하면 빠른 하드웨어에서 시각적인 매력을 잃게 됩니다. 결론적으로 그리 좋은 방법은 아니라고 생각됩니다.


### 가변 FPS에 따른 게임속도

#### 구현
게임 루프의 또 다른 구현은 가능한 빨리 실행하고 `FPS`가 게임 속도를 지시하도록 하는 것입니다. 게임은 이전 프레임의 시차(delta time)로 업데이트됩니다.

```cpp
uint32 prevFrameMs;
uint32 currFrameMs = GetMilliseconds();

bool running = true;
while (running) {
    prevFrameMs = currFrameMs;
    currFrameMs = GetMilliseconds();

    const uint32 deltaMs = currFrameMs - prevFrameMs;
    Update(deltaMs);
    Render();
}
```

`Update()` 함수는 `deltaMs(틱간 시간차)`를 고려해야하기 때문에 게임코드가 조금 더 복잡해집니다. 그러나 여전히 그렇게 어렵지는 않습니다. 처음에는 이것이 우리 문제에 대한 이상적인 해결책으로 보입니다. 많은 똑똑한 프로그래머가 이런 종류의 게임 루프를 구현하는 것을 보았습니다. 아마 그들이 이 글을 읽고 조금더 문제에 대해서 깊히 생각할 수 있었으면 어땠을까 생각해봅니다. 이 루프가 느리고/빠른 하드웨어 모두에 심각한 문제가 있을 수 있음을 아래에서 살펴보도록 하겠습니다.

#### 느린 하드웨어
느린 하드웨어는 때때로 게임이 "무겁게"(심하게 저는)되는 일부 지점에서 특정 지연을 유발할 수 있습니다. 이는 특정 시간에 너무 많은 다각형이 표시되는 3D 게임에서 발생할 수 있습니다. 카메라가 비추는 곳에 많은 오브젝트가 있을 경우등을 생각해 볼 수 있습니다. 이 프레임 속도의 저하는 입력응답 시간 및 플레이어의 반응 시간에도 악영향을 줍니다.
게임을 업데이트하면 지연이 느껴지고 게임 상태가 띄엄띄엄 업데이트 됩니다. 결과적으로 플레이어와 `AI`의 반응 시간이 느려지고 간단한 조작이 실패하거나 심지어 불가능해질 수도 있습니다. 예를들어, 일반적으로 `FPS`로 피할 수 있는 장애물은 느린 `FPS`로는 피할 수 없습니다. 느린 하드웨에서 더 심각한 문제는 물리학을 사용하면 시물레이션이 폭팔할수도 있다는 것입니다.

#### 빠른 하드웨어
빠른 하드웨어에서 위의 게임 루프가 어떨게 잘못될 수 있는지 궁금할 것입니다. 불행하게도 컴퓨터에서 수학에 대해 설명할 수 있습니다. `float` 또는 `double` 값의 메모리 공간은 제한되어 있으므로 일부 값은 표현할 수 없습니다. 예를들어, 0.1은 2진수로 표현할 수 없기 때문에 이중으로 저장될때 반올림됩니다. 파이썬에서의 예를 보겠습니다.
```py
>>> 0.1
0.10000000000000001
```

이것 자체는 극적이지 않지만 이로써 생기는 부작용은 클 수 있습니다. 밀리세컨드 당 0.001 단위를 속도를 가진 경주용 자동차를 가지고 있다고 가정해 봅시다. 10초 후에 경주용 자동차는 10.0의 거리를 이동할 것입니다. 게임이 하는것처럼 계산을 나눈다면 초당 프레임을 입력으로 사용하여 다음과 같은 기능을 수행할 수 있습니다.
```py
def get_distance(fps):
    msecs_per_frame = 1000 / fps
    total_ticks = 0
    distance = 0.0
    speed_per_tick = 0.001
    if total_ticks < 10000:
        distance += speed_per_tick * msecs_per_frame
        total_ticks += msecs_per_frame
    return distance
```

이제 초당 40 프레임으로 거리를 계산해 보겠습니다.
```py
>>> get_distance(40)
10.000000000000075
```

예상했던 `10.0`이 아닙니다. 반올림 오류가 커졌습니다. 자 그럼 초당 100프레임 상황에서는 어떤일이 발생할지 알아보겠습니다.
```py
>>> get_distance(100)
9.9999999999998312
```

이전보다 오류가 더 커져버렸습니다. 100FPS에서 더많은 추가가 있기 때문에 반올림 오류가 커질 수 있습니다. 따라서 게임은 초당 40 또는 100 프레임을 실행할때 게임상태가 달라질 수 있습니다.
```py
>>> get_distance(40) - get_distance(100)
2.4336088699783431e-13
```

이 차이가 너무 작아서 게임 자체에서 볼수 없다고 생각할 수도 있습니다. 그러나 이 잘못된 값을 사용하여 더 많은 계산을 수행하게 되면 실제 문제가 시작됩니다. 이렇게 하면 작은 오류가 커질 수 있고 높은 프레임 속도로 게임 상태가 이상해질 수 있습니다. 그럴 가능성이 있을까요? 네 매우 많이 있습니다. 이런 종류의 게임 루프를 사용한 게임을 보고 높은 프레임 속도에서 실제로 문제를 일으켰습니다. 프로그래머가 문제가 게임의 핵심에 숨어 있음을 알게된 후에는 많은 코드 재 작성만으로 문제를 해결할 수 있었습니다. 즉, 문제가 일단 발생하면 디버깅하기 굉장히 어려워진다는게 큰 문제입니다.

#### 결론
이런 종류의 게임 루프는 첫눈에 매우 좋아 보일 수 있지만, 무턱대고 사용하면 위험할 수 있습니다. 느리고 빠른 하드웨어 모두 심각한 문제를 일으킬 수 있습니다. 또한 고정 프레임 속도를 사용할때 보다 게임 업데이트 기능을 구현하기 어렵습니다. 현재 대부분의 게임 엔진은 이러한 방식을 사용하고 있습니다. 그렇다면, 왜 다들 사용할까요? 대안은 무엇일까요? 대안에 대해서는 2편에서 얘기하도록 하겠습니다.


### 최대 FPS의 일정한 게임 속도

#### 구현
`Constant Game Speed`에 의존하는 첫번째 솔루션인 `FPS`는 느린 하드웨에서 실행할때 문제가 있습니다. 이 경우 게임 속도와 프레임 속도가 모두 떨어집니다. 이에 대한 가능한 해결책은 게임을 해당 속도로 계속 업데이트하지만 렌더링 프레임 속도는 줄이는 것입니다. 다음 게임 루프를 사용하여 수행할 수 있습니다.

```cpp
const uint32 TICKS_PER_SECONDS = 50;
const uint32 MSECS_PER_FRAME = 1000 / TICKS_PER_SECOND;
const uint32 MAX_FRAME_SKIP = 10;

uint32 nextFrameMs = GetMilliseconds();
uint32 skippedFrameCount;

bool running = true;
while (running) {
    skippedFrameCount = 0;
    while (GetMilliseconds() > nextFrameMs && skippedFrameCount < MAX_FRAME_SKIP) {
        Update();

        nextFrameMs += MSECS_PER_FRAME;
        skippedFrameCount++;
    }

    Render();
}
```

게임은 초당 50번 안정적으로 업데이트되며 렌더링은 최대한 빨리 수행됩니다. 렌더링이 초당 50회 이상 수행되면 일부 후속 프레임이 동일하므로 실제 비주얼 프레임은 초당 최대 50프레임으로 사라집니다. 느린 하드웨어에서 실행하는 경우 게임 업데이트 루프가 `MAX_FRAME_SKIP`에 도달할때까지 프레임 속도가 떨어질 수 있습니다. 실제로 이것은 렌더링 `FPS`가 `5(FRAMES_PER_SECOND / MAX_FRAME_SKIP)` 아래로 떨어지면 실제 게임 속도가 느려진다는 것을 의미합니다.

#### 느린 하드웨어
느린 하드웨어에서는 초당 프레임이 떨어지지만 게임 자체는 정상속도로 실행됩니다. 하드웨어가 여전히 이것을 처리할 수 없다면, 게임 자체는 느리게 실행되고 프레임 속도는 전혀 부드럽지 않습니다.

#### 빠른 하드웨어
이 게임은 빠른 하드웨어에서는 문제가 없지만 첫번째 솔루션과 마찬가지로 더 높은 프레임 속도에 사용할 수 있는 많은 귀중한 클럭 사이클을 낭비하고 있습니다. 빠른 업데이트 속도와 느린 하드웨어에서 실행할 수 있는 범위의 균형을 찾는것이 중요합니다.

#### 결론
`최대 FPS`로 일정한 게임 속도를 사용하는 것은 구현하기 쉽고 게임 코드를 단순하게 유지하는 솔루션입니다. 그러나 여전히 몇가지 문제가 있습니다. `높은 FPS`를 정의하면 여전히 느린 하드웨어에 문제가 발생할 수 있지만, `낮은 FPS`를 정의하면 빠른 하드웨어에 대한 시각적 호소력이 낭비됩니다.


### 가변 FPS와 독립적인 일정한 게임 속도

#### 구현
느린 하드웨어에서 더 빠르게 실행하고 더 빠른 하드웨에서 시각적으로 더 비대칭적으로 위의 솔루션을 더욱 향상 시킬 수 있습니까? 쉽게 접근해 보겠습니다. 게임 상태 자체는 초당 60번 업데이트할 필요가 없습니다.

`플레이어 입력`, `AI` 및 `게임 상태 업데이트`는 초당 25프레임이면 충분합니다. 이제 `Update()`을 초당 25번 호출해 봅시다.

반면 렌더링은 하드웨어가 처리할 수 있을만큼 빨라야합니다. 그러나, 느린 프레임 속도는 게임 업데이트를 방해하지 않아야합니다.

이를 구현해보면 다음과 같을것입니다.

```cpp
const uint32 FRAMES_PER_SECONDS = 25;
const uint32 MSECS_PER_FRAME = 1000 / TICKS_PER_SECOND;
const uint32 MAX_FRAME_SKIP = 5;

uint32 nextFrameMs = GetMilliseconds();
uint32 skippedFrameCount;
float interpolation;

bool running = true;
while (running) {
    skippedFrameCount = 0;
    while (GetMilliseconds() > nextFrameMs && skippedFrameCount < MAX_FRAME_SKIP) {
        Update();
        nextFrameMs += MSECS_PER_FRAME;
        skippedFrameCount++;
    }

    interpolation = float(GetMilliseconds() + MSECS_PER_FRAME - nextFrameMs) / float(MSECS_PER_FRAME);
    Render(interpolation);
}
```

이런 종류의 게임 루프를 사용하면 Update() 구현이 쉬워집니다. 그러나 Render() 함수는 더욱더 복잡해지는 무담을 가지게 되었습니다. 보간을 인수로 취하는 예측 함수를 구현해야합니다. 하지만, 크게 복잡한 작업은 아닙니다. 이 보간법과 예측법이 어떻게 작동하는지 아래에서 설명하지만 먼저 왜 그것이 필요한지 아래에서 살펴보겠습니다.

#### 보간의 필요성
게임 상태는 초당 25회 업데이트 되므로 렌더링에서 보간을 사용하지 않으면 프레임도 이속도로 표시됩니다. 25FPS는 사람들이 생각하는 것처럼 느리지는 않습니다.(참고로 영화는 초당 24프레임으로 실행됩니다.)  따라서 시각적으로 즐거운 경험을 위해서는 25FPS가 충분하지만, 빠르게 움직이는 물체의 경우 FPS를 더 많이 수행할때 조금더 부드럽게 보일 수 있습니다. 그래서 우리가 할 수 있는 것은 빠름 움직임을 프레임 사이에서보다 매끄럽게 만드는 것입니다.

그리고 이것은 보간과 예측 함수가 해결책을 제공할 수 있습니다.

### 보간 및 예측
게임 코드가 초당 자신의 프레임으로 실행된다고 말했드이 프레임을 그리거나 렝더링할 때 2개의 해치 틱 사이에 있을 가능성이 있습니다. 10시간동안 게임 상태를 방금 업데이트했다고 가정하면 이제 장면을 렌더링할 것입니다. 이 렌더링은 10th~11th 게임 업데이트 사이에 있습니다. 그래서 렌더가 약 10.3에 있을 가능성이 있습니다. 그런 다음 `interpolation` 값은 0.3을 유지합니다.

이 예제를 보시죠. 

다음과 같이 움직이는 자동차가 있다고 가정해 보겠습니다.
```cpp
위치 = 위치 + 속도;
```

10th 액터 틱에서 위치가 500이고 속도가 100인 경우 11th 액터 틱에서 600이라는 위치가 됩니다. 그러면 자동차를 렌더링할때 자동차를 어디에 위치시켜야 할까요? 마지막 액터 틱의 위치(이 경우 500)를 취할 수 있습니다만, 더 좋은 방법은 자동차가 정확히 10.3 위치를 예측하는 것입니다.
```cpp
보여지는 위치 = 위치 + (속도 * 보간)
```

그러면 자동차는 530 위치에 렌더링 됩니다. 따라서 기본적으로 보간 변수에는 이전 액터 틱 사이의 값이 포함되어 있습니다. (이전=0.0, 다음=1.0).
다음으로 해야할 일은 자동차, 카메라, ...가 렌더링 시간에 배치될 "예측" 기능을 만드는 것입니다. 이 예측 기능은 물체의 속도, 조향 또는 회전 속도를 기반으로 할 수 있습니다. 프레임 사이의 물건을 부드럽게 하기 위해 사용하기 때문에 복잡할 필요가 없습니다. 충돌이 감지되기 직전에 객체가 다른 객체로 렌더링될 수 있습니다. 그러나 우리가 전에 보았던 것처럼, 게임은 초당 25프레임으로 업데이트됩니다. 따라서 이런일이 발생하면 오류는 인간의 눈에는 거의 눈에 띄지 않습니다.

#### 느린 하드웨어
대부분의 경우 `Update()`은 `Render()` 보다 시간이 덜 걸립니다. 실제로 느린 하드웨에서도 `Update()` 함수가 초당 25번 실행될 수 있다고 가정할 수 있습니다. 따라서 게임은 초당 15프레임만 표시하더라도 플레이어 입력을 처리하고 많은 문제없이 게임 상태를 업데이트합니다.

#### 빠른 하드웨어
빠른 하드웨어에서는 게임이 초당 25배의 일정한 속도로 계속 실행되지만 화면 업데이트는 이보다 훨씬 빠릅니다. 보간 / 예측 방법은 게임이 실제로 높은 프레임 속도로 실행되고 있다는 시각적 매력을 만듭니다. 좋은 점은 `FPS`를 임의로 설정할수 있다는 것입니다. 매 프레임마다 게임 상태를 업데이트 하지 않고 시각화만 하기 때문에 게임은 위에서 설명한 두 번째 방법보다 `FPS`가 더 높습니다.

#### 결론
게임 상태를 `FPS`와 독립적으로 만드는 것이 게임 루프를 구현하는 가장 좋은 방법인 것 같습니다. 그러나 `Render()`에 예측 함수를 구현해야하는 부담이 생기지만, 간단한 계산만 해주면 되므로 부담은 크지 않습니다.

### 전반적인 결론
게임 루프에는 생각보다 많은 것이 있습니다. 우리는 몇가지 가능한 구현을 생각해 보았습니다, 반드시 피해야할 것중 하나가 있는것 같습니다. 그것은 `가변 FPS`가 게임 속도를 지시하는 것입니다. 일정한 프레임 속도는 모바일 장치를 위한 좋은 솔루션이 될수 있지만, 하드웨어에 있는 모든 것을 얻으려면 `FPS`가 게임 속도와 완전히 독립적이며 높은 프레임 속도에 대한 예측 기능을 사용하는 게임 루프를 사용하는 것이 가장 좋습니다. 예측 가능에 신경 쓰지 않으려면 최대 프레임 속도로 작업할 수 있지만 느리고 빠른 하드웨어에 적합한 게임 업데이트 속도를 찾는 것은 까다로울 수 있습니다.


## 다음편 예고

다음 편에서는 위에서 설명한 것들을 개선한 틱 시스템에 대하여 설명 하도록 하겠습니다.
